#!/bin/python3
import asm86
import argparse
import random

data = {}
packs = {}
labels = []
bools = []
mice = []
pixs = []
constants = []
init_vars = ""
letterdict = {
    "a": "0x1E",
    "b": "0x30",
    "c": "0x2E",
    "d": "0x20",
    "e": "0x12",
    "f": "0x21",
    "g": "0x22",
    "h": "0x23",
    "i": "0x17",
    "j": "0x24",
    "k": "0x25",
    "l": "0x26",
    "m": "0x32",
    "n": "0x31",
    "o": "0x18",
    "p": "0x19",
    "q": "0x10",
    "r": "0x13",
    "s": "0x1F",
    "t": "0x14",
    "u": "0x16",
    "v": "0x2F",
    "w": "0x11",
    "x": "0x2D",
    "y": "0x15",
    "z": "0x2C",
    "1": "0x02",
    "2": "0x03",
    "3": "0x04",
    "4": "0x05",
    "5": "0x06",
    "6": "0x07",
    "7": "0x08",
    "8": "0x09",
    "9": "0x0A",
    "0": "0x0B",
    "lshift": "0x2A",
    "rshift": "0x36",
    "ctrl": "0x1D",
    "alt": "0x38",
    "up": "0x48",
    "down": "0x50",
    "left": "0x4B",
    "right": "0x4D",
    "enter": "0x1C",
    "space": "0x39",
    "backspace": "0x0E",
    "tab": "0x0F",
    "esc": "0x01"
}

# THIS CODE IS FUCKING TERRIBLE NO ONE SHOULD EVER USE IT
# mov esi, [lfb_addr]
# mov edx, [lfb_pitch]

# mov eax, edx
# imul eax, {y}
# add esi, eax
# mov edi, esi

# mov ebx, 1      
# mov ecx, 1  

# push ecx 
# mov edi, esi
# add edi, {x}*3     

# mov byte [edi], 0x{color.strip()[5:7]} 
# mov byte [edi+1], 0x{color.strip()[3:5]}
# mov byte [edi+2], 0x{color.strip()[1:3]}
# add edi, 3

# pop ecx
# add esi, edx       

def asmrandom(max1, min1, out):
    return f"""
rdtsc
xor eax, edx


mov eax, eax 
mov ecx, {max1}
sub ecx, {min1}

xor edx, edx
div ecx 
mov eax, edx 
add eax, {min1}
mov dword {out}, eax
    """

def time_wait(ticks, rdm):
    return f"""
mov ecx, {ticks}
mov eax, ecx
imul eax, 135
mov ebx, 100
cdq
idiv ebx
mov ecx, eax
pusha
mov al, 0x36
out 0x43, al
mov bx, 1193
delay_loop_inline{rdm}:
    mov ax, bx
wait_inline{rdm}:
    out 0x40, al
    dec ax
    jnz wait_inline{rdm}
    loop delay_loop_inline{rdm}
popa
    """

def draw_pixel(x1, y1, x2, y2, color, rdm):
    return f"""

    mov esi, [lfb_addr]  
    mov edx, [lfb_pitch]  

    mov eax, {y1}
    imul eax, edx         
    add esi, eax
    mov edi, esi

    mov eax, {y2}
    sub eax, {y1}          
    mov ebx, eax

row_loop{rdm}:
    push ebx                  
    mov edi, esi
    mov eax, {x1}
    imul eax, 3              
    add edi, eax         

    mov eax, {x2}
    sub eax, {x1}        
    mov ecx, eax

pixel_loop{rdm}:
    mov byte [edi], 0x{color.strip()[5:7]} 
    mov byte [edi+1], 0x{color.strip()[3:5]} 
    mov byte [edi+2], 0x{color.strip()[1:3]} 
    add edi, 3
    loop pixel_loop{rdm}

    pop ebx
    add esi, edx        
    dec ebx
    jnz row_loop{rdm}


"""

def arguments(cmd, splitter, amount):
    replacement = random.randint(1, 10000)
    while str(replacement) in cmd:
        replacement = random.randint(1, 10000)
    cmd = cmd.replace(splitter, str(replacement), amount)
    return cmd.split(str(replacement))

def kx86_compile(body, splitter = ";"):
    while "/:" and ":/" in body:
        body = body[:body.index("/:")] + body[body.index(":/") + 2:]
    final = ""
    global data, packs, labels, bools, mice, letterdict, constants, init_vars, pixs
    body = body.split(splitter)
    for i in range(len(body)):
        cmd = body[i].strip()
        if cmd.strip() == "":
            continue
        cmd = arguments(cmd, ":", 1)
        match cmd[0].strip():
            case "rect":
                rect = random.randint(1,10000)
                while rect in pixs:
                    rect = random.randint(1,10000)
                pixs.append(rect)
                cmd[1] = arguments(cmd[1].strip(), ",", 4)
                final += draw_pixel(cmd[1][0].strip(), cmd[1][1].strip(), cmd[1][2].strip(), cmd[1][3].strip(), cmd[1][4].strip(), rect)
            case "pause":
                rect = random.randint(1,10000)
                while rect in pixs:
                    rect = random.randint(1,10000)
                pixs.append(rect)
                final += time_wait(cmd[1].strip(), rect)
            
            case "pack":
                cmd[1] = arguments(cmd[1].strip(), ",", 1)
                packs[cmd[1][0].strip()] = cmd[1][1].strip()
            case "asmpack":
                cmd[1] = arguments(cmd[1].strip(), ",", 1)
                packs[cmd[1][0].strip()] = cmd[1][1].strip()
            case "asmcall":
                final += "\n" + packs[cmd[1].strip()] + "\n"
            case "call":
                params = 1
                try:
                    func = packs[cmd[1][:cmd[1].index("~")].strip()]
                    while f"${params}" in func:
                        params += 1
                    cmd[1] = arguments(cmd[1].strip(), "~", params)
                    for g in range(1, params):
                        func = func.replace(f"${g}", cmd[1][g].strip())
                    final += kx86_compile(func, "&") + "\n"
                except:
                    final += kx86_compile(packs[cmd[1].strip()], "&") + "\n"


            case "inf":
                label = random.randint(1,10000)
                while label in labels:
                    label = random.randint(1,10000)
                labels.append(label)

                params = 0
                try:
                    func = packs[cmd[1][:cmd[1].index("~")].strip()]
                    while f"${params + 1}" in func:
                        params += 1
                    cmd[1] = arguments(cmd[1].strip(), "~", params + 1)
                    for g in range(1, params + 1):
                        func = func.replace(f"${g}", cmd[1][g].strip())

                    final += f"\nj{label}:\n" + kx86_compile(func, "&") + f"\njmp j{label}\n"
                except:
                    final += f"\nj{label}:\n" + kx86_compile(packs[cmd[1].strip()], "&") + f"\njmp j{label}\n"

            case "//":
                pass

            case "num":
                cmd[1] = arguments(cmd[1].strip(), ",", 1)
                data["[" + cmd[1][0].strip() + "]"] = "num"
                init_vars += "\n" + cmd[1][0].strip() + f":\ndd {cmd[1][1].strip()}\n"
            case "str":
                cmd[1] = arguments(cmd[1].strip(), ",", 1)
                data["[" + cmd[1][0].strip() + "]"] = "str"
                init_vars += "\n" + cmd[1][0].strip() + f":\ndb {cmd[1][1].strip().replace("<endl>", '", 0x0D, 0x0A, "')}, 0\n"
            case "strarray":
                cmd[1] = arguments(cmd[1].strip(), ",", 1)
                data["[" + cmd[1][0].strip() + "]"] = "str"
                init_vars += "\n" + cmd[1][0].strip() + f":\ndb {cmd[1][1].strip().replace("<endl>", '", 0x0D, 0x0A, "')}, 0\n"

            case "edit": # edit 'edit' for strings iykykykkykyk
                cmd[1] = arguments(cmd[1].strip(), ",", 1)
                final += f"\nmov dword {cmd[1][0].strip()}, {cmd[1][1].strip()}\n"

            case "if":
                bool_num = random.randint(1,10000)
                while bool_num in bools:
                    bool_num = random.randint(1,10000)
                bools.append(bool_num)
                
                
                cmd[1] = arguments(cmd[1].strip(), ",", 2)
                if ">=" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split(">=")
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, {bool[1].strip()}\njge true{bool_num}\njl false{bool_num}\n"
                elif "<=" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("<=")
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, {bool[1].strip()}\njle true{bool_num}\njg false{bool_num}\n"
                elif "==" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("==")
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, {bool[1].strip()}\nje true{bool_num}\njne false{bool_num}\n"
                elif "!=" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("!=")
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, {bool[1].strip()}\njne true{bool_num}\nje false{bool_num}\n"
                elif "<" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("<")
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, {bool[1].strip()}\njl true{bool_num}\njge false{bool_num}\n"
                elif ">" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split(">")
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, {bool[1].strip()}\njg true{bool_num}\njle false{bool_num}\n"
                elif ">=!" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split(">=!")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, [c{constant}]\njge true{bool_num}\njl false{bool_num}\n"
                elif "<=!" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("<=!")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, [c{constant}]\njle true{bool_num}\njg false{bool_num}\n"
                elif "==!" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("==!")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, [c{constant}]\nje true{bool_num}\njne false{bool_num}\n"
                elif "!=!" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("!=!")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, [c{constant}]\njne true{bool_num}\nje false{bool_num}\n"
                elif "<!" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("<!")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, [c{constant}]\njl true{bool_num}\njge false{bool_num}\n"
                elif ">!" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split(">!")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, [c{constant}]\njg true{bool_num}\njle false{bool_num}\n"
                else:
                    bool = cmd[1][0].strip() # this is the key that you're checking is pressed
                    final += f"""
check_keyboard{bool_num}:
    in al, 0x64
    test al, 1
    jz done{bool_num}
    in al, 0x60
    cmp al, 0x80
    jb pressed{bool_num}
    sub al, 0x80
    mov byte [KEYS+eax], 0
    jmp done{bool_num}

pressed{bool_num}:
    mov byte [KEYS+eax], 1

done{bool_num}:
    cmp byte [KEYS+{letterdict[bool.lower()[-1]]}], 1
    jne false{bool_num}
    sub byte [KEYS+{letterdict[bool.lower()[-1]]}], 1
    jmp true{bool_num}

"""
                final += f"\ntrue{bool_num}:\n\n"
                params = 0
                cmd[1][1] = cmd[1][1].strip()[5:]
                try:
                    
                    func = packs[cmd[1][1][:cmd[1][1].index("~")].strip()]
                    while f"${params + 1}" in func:
                        params += 1
                    cmd[1][1] = arguments(cmd[1][1].strip(), "~", params + 1)
                    for g in range(1, params + 1):
                        func = func.replace(f"${g}", cmd[1][1][g].strip())
                        final += "\n" + kx86_compile(func, "&") + "\n"
                except:
                    final += "\n" + kx86_compile(packs[cmd[1][1].strip()], "&") + "\n"
                final += "\n" + f"jmp escape{bool_num}" + "\n"
                final += f"\nfalse{bool_num}:\n\n"
                if "NONE" not in cmd[1][2].strip(): # DO THIS AGAIN THE TRUE GOES INTO THE FALSE OH NO

                    params = 0
                    try:
                        func = packs[cmd[1][2][:cmd[1][2].index("~")].strip()]
                        while f"${params + 1}" in func:
                            params += 1
                        cmd[1][2] = arguments(cmd[1][2].strip(), "~", params + 1)
                        for g in range(1, params + 1):
                            func = func.replace(f"${g}", cmd[1][2][g].strip())
                            final += "\n" + kx86_compile(func, "&") + "\n"
                    except:
                        final += "\n" + kx86_compile(packs[cmd[1][2].strip()[5:]], "&") + "\n"

                    final += "\n" + kx86_compile(packs[cmd[1][2].strip()[5:]], "&") + "\n"
                final += "\n" + f"escape{bool_num}:" + "\n"
                    
            case "while":
                bool_num = random.randint(1,10000)
                while bool_num in bools:
                    bool_num = random.randint(1,10000)
                bools.append(bool_num)
                
                cmd[1] = arguments(cmd[1].strip(), ",", 1)
                final += f"\nwhile{bool_num}:\n"
                if ">=" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split(">=")
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, {bool[1].strip()}\njge true{bool_num}\njl false{bool_num}\n"
                elif "<=" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("<=")
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, {bool[1].strip()}\njle true{bool_num}\njg false{bool_num}\n"
                elif "==" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("==")
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, {bool[1].strip()}\nje true{bool_num}\njne false{bool_num}\n"
                elif "!=" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("!=")
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, {bool[1].strip()}\njne true{bool_num}\nje false{bool_num}\n"
                elif "<" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("<")
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, {bool[1].strip()}\njl true{bool_num}\njge false{bool_num}\n"
                elif ">" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split(">")
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, {bool[1].strip()}\njg true{bool_num}\njle false{bool_num}\n"
                elif ">=!" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split(">=!")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, [c{constant}]\njge true{bool_num}\njl false{bool_num}\n"
                elif "<=!" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("<=!")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, [c{constant}]\njle true{bool_num}\njg false{bool_num}\n"
                elif "==!" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("==!")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, [c{constant}]\nje true{bool_num}\njne false{bool_num}\n"
                elif "!=!" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("!=!")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, [c{constant}]\njne true{bool_num}\nje false{bool_num}\n"
                elif "<!" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split("<!")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, [c{constant}]\njl true{bool_num}\njge false{bool_num}\n"
                elif ">!" in cmd[1][0]:
                    bool = cmd[1][0].strip()
                    bool = bool.split(">!")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nmov eax, {bool[0].strip()}\ncmp eax, [c{constant}]\njg true{bool_num}\njle false{bool_num}\n"
                else:
                    bool = cmd[1][0].strip() # this is the key that you're checking is pressed
                    final += f"""
check_keyboard{bool_num}:
    in al, 0x64
    test al, 1
    jz done{bool_num}
    in al, 0x60
    cmp al, 0x80
    jb pressed{bool_num}
    sub al, 0x80
    mov byte [KEYS+eax], 0
    jmp done{bool_num}

pressed{bool_num}:
    mov byte [KEYS+eax], 1

done{bool_num}:
    cmp byte [KEYS+{letterdict[bool.lower()[-1]]}], 1
    jne false{bool_num}
    sub byte [KEYS+{letterdict[bool.lower()[-1]]}], 1
    jmp true{bool_num}

"""
                final += f"\ntrue{bool_num}:\n\n"
                params = 0
                try:
                    cmd[1][1] = cmd[1][1].strip()[5:]
                    func = packs[cmd[1][1][:cmd[1][1].index("~")].strip()]
                    while f"${params + 1}" in func:
                        params += 1
                    cmd[1][1] = arguments(cmd[1][1].strip(), "~", params + 1)
                    for g in range(1, params + 1):
                        func = func.replace(f"${g}", cmd[1][1][g].strip())
                        final += "\n" + kx86_compile(func, "&") + "\n"
                except:
                    final += "\n" + kx86_compile(packs[cmd[1][1].strip()[5:]], "&") + "\n"


                final += "\n" + f"jmp while{bool_num}" + "\n"
                final += f"\nfalse{bool_num}:\n\n"
            case "op":
                cmd[1] = arguments(cmd[1].strip(), ",", 1)
                if "---" in cmd[1][0]: # add compiler type corresponding THIS ISNT DONE FUNCTIONS NEED TO BE ASSSIGNED
                    bool = cmd[1][0].strip()
                    bool = bool.split("---")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nfld dword {bool[0].strip()}\nfsub dword [c{constant}]\nfstp dword {cmd[1][1].strip()}"
                elif "+++" in cmd[1][0]: # add compiler type corresponding THIS ISNT DONE FUNCTIONS NEED TO BE ASSSIGNED
                    bool = cmd[1][0].strip()
                    bool = bool.split("+++")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nfld dword {bool[0].strip()}\nfadd dword [c{constant}]\nfstp dword {cmd[1][1].strip()}"
                elif "***" in cmd[1][0]: # add compiler type corresponding THIS ISNT DONE FUNCTIONS NEED TO BE ASSSIGNED
                    bool = cmd[1][0].strip()
                    bool = bool.split("***")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nfld dword {bool[0].strip()}\nfmul dword [c{constant}]\nfstp dword {cmd[1][1].strip()}"
                elif "///" in cmd[1][0]: # add compiler type corresponding THIS ISNT DONE FUNCTIONS NEED TO BE ASSSIGNED
                    bool = cmd[1][0].strip()
                    bool = bool.split("///")
                    constant = random.randint(1,100000)
                    while constant in constants:
                        constant = random.randint(1,100000)
                    constants.append(constant)
                    init_vars += f"""
c{constant}:
dd {bool[1].strip()}
"""
                    final += f"\nfld dword {bool[0].strip()}\nfdiv dword [c{constant}]\nfstp dword {cmd[1][1].strip()}"
                elif "++" in cmd[1][0]: # add compiler type corresponding THIS ISNT DONE FUNCTIONS NEED TO BE ASSSIGNED
                    bool = cmd[1][0].strip()
                    bool = bool.split("++")
                    final += f"\nmov eax, {bool[0].strip()}\nadd eax, {bool[1].strip()}\nmov dword {cmd[1][1].strip()}, eax"
                elif "--" in cmd[1][0]: # add compiler type corresponding THIS ISNT DONE FUNCTIONS NEED TO BE ASSSIGNED
                    bool = cmd[1][0].strip()
                    bool = bool.split("--")
                    final += f"\nmov eax, {bool[0].strip()}\nsub eax, {bool[1].strip()}\nmov dword {cmd[1][1].strip()}, eax"
                elif "**" in cmd[1][0]: # add compiler type corresponding THIS ISNT DONE FUNCTIONS NEED TO BE ASSSIGNED
                    bool = cmd[1][0].strip()
                    bool = bool.split("**")
                    final += f"\nmov eax, {bool[0].strip()}\nimul eax, {bool[1].strip()}\nmov dword {cmd[1][1].strip()}, eax"
                elif "//" in cmd[1][0]: # add compiler type corresponding THIS ISNT DONE FUNCTIONS NEED TO BE ASSSIGNED
                    bool = cmd[1][0].strip()
                    bool = bool.split("//")
                    final += f"\nmov eax, {bool[0].strip()}\ncdq\nmov ecx, {bool[1].strip()}\nidiv ecx\nmov dword {cmd[1][1].strip()}, eax"
                elif "/" in cmd[1][0]: # add compiler type corresponding THIS ISNT DONE FUNCTIONS NEED TO BE ASSSIGNED
                    bool = cmd[1][0].strip()
                    bool = bool.split("/")
                    final += f"\nfld dword {bool[0].strip()}\nfdiv dword {bool[1].strip()}\nfstp dword {cmd[1][1].strip()}"
                elif "*" in cmd[1][0]: # add compiler type corresponding THIS ISNT DONE FUNCTIONS NEED TO BE ASSSIGNED
                    bool = cmd[1][0].strip()
                    bool = bool.split("*")
                    final += f"\nfld dword {bool[0].strip()}\nfmul dword {bool[1].strip()}\nfstp dword {cmd[1][1].strip()}"
                elif "+" in cmd[1][0]: # add compiler type corresponding THIS ISNT DONE FUNCTIONS NEED TO BE ASSSIGNED
                    bool = cmd[1][0].strip()
                    bool = bool.split("+")
                    final += f"\nfld dword {bool[0].strip()}\nfadd dword {bool[1].strip()}\nfstp dword {cmd[1][1].strip()}"
                elif "-" in cmd[1][0]: # add compiler type corresponding THIS ISNT DONE FUNCTIONS NEED TO BE ASSSIGNED
                    bool = cmd[1][0].strip()
                    bool = bool.split("-")
                    final += f"\nfld dword {bool[0].strip()}\nfsub dword {bool[1].strip()}\nfstp dword {cmd[1][1].strip()}"

                elif ">f" in cmd[1][0]: # add compiler type corresponding THIS ISNT DONE FUNCTIONS NEED TO BE ASSSIGNED
                    bool = cmd[1][0].strip()
                    bool = bool.split(">f")
                    final += f"""
fild dword {bool[0].strip()}
fstp dword {cmd[1][1].strip()}
"""
                if ">i" in cmd[1][0]: # add compiler type corresponding THIS ISNT DONE FUNCTIONS NEED TO BE ASSSIGNED
                    bool = cmd[1][0].strip()
                    bool = bool.split(">i")
                    final += f"""
fld dword {bool[0].strip()}
fistp dword {cmd[1][1].strip()}
"""
            case "array":
                cmd[1] = arguments(cmd[1].strip(), ",", 1)
                data["[" + cmd[1][0].strip() + "]"] = "array"
                init_vars += "\n" + cmd[1][0].strip() + f":\ndd {cmd[1][1].strip()}\n"
            case "random":
                cmd[1] = arguments(cmd[1].strip(), ",", 2)
                final += asmrandom(cmd[1][0].strip(), cmd[1][1].strip(), cmd[1][2].strip())
            case "hang":
                final += "\nhlt\n"
            case "access":
                cmd[1] = arguments(cmd[1].strip(), ",", 2)
                final += f"""
mov eax, {cmd[1][1].strip()}
mov dword {cmd[1][2].strip()}, [{cmd[1][0].strip()[1:-1]} + eax*4]
                """
            case "arrayedit":
                cmd[1] = arguments(cmd[1].strip(), ",", 2)
                final += f"""
mov eax, {cmd[1][1].strip()}
mov dword [{cmd[1][0].strip()[1:-1]} + eax*4], {cmd[1][2].strip()}
                """


    return final

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-f", "--file", type=str, nargs="+", help="file or files to compile")
    parser.add_argument("-o", "--output", type=str, help="file to output to")
    parser.add_argument("-c", "--compile-mode", type=str, help="default is bin, can switch to asm or alq (auto-launch qemu)") 

    args = parser.parse_args()
    body = ""
    for i in range(len(args.file)):
        with open(args.file[i], "r") as f:
            body += "\n" + f.read()
    finale = kx86_compile(body.replace("hang;", "hang:;").replace("hang&", "hang:&").replace("hang &", "hang: &")).replace("@", " + 4*").replace("{", "").replace("}", "")
    asm86.kernel += init_vars.replace("@", " + 4*").replace("{", "").replace("}", "") + "\nsection .text\n" + finale
    if args.compile_mode.strip().lower() != "alq":
        if args.compile_mode:
            asm86.create_image(args.output, args.compile_mode.strip().lower())
        else:
            asm86.create_image(args.output)
    else:
        asm86.create_image(show="jit")